# Navigation Guide - Using go_router_builder with coore

This guide shows how to implement type-safe, scalable navigation in your app using `go_router_builder` with the `coore` package.

## Table of Contents

- [Overview](#overview)
- [Setup](#setup)
- [Defining Routes](#defining-routes)
- [Navigation from Widgets](#navigation-from-widgets)
- [Navigation from BLoCs/Services](#navigation-from-blocsservices)
- [Advanced Patterns](#advanced-patterns)
- [Migration Guide](#migration-guide)

## Overview

### Why go_router_builder?

The `coore` package provides `CoreRouter` to configure and manage your `GoRouter` instance. For type-safe navigation, use the official `go_router_builder` package instead of custom wrappers.

**Benefits:**
- ✅ **Official solution**: Maintained by the Flutter team
- ✅ **Code generation**: Automatic type-safe navigation methods
- ✅ **Zero boilerplate**: No manual parameter classes needed
- ✅ **IDE support**: Full autocomplete and refactoring
- ✅ **Compile-time safety**: Wrong types won't compile

### Architecture

```
Your App
├── app_router.dart (defines routes with annotations)
├── app_router.g.dart (generated by go_router_builder)
└── CoreRouter (from coore package)
    └── Configures GoRouter with your routes
```

## Setup

### 1. Add Dependencies

```yaml
# pubspec.yaml
dependencies:
  coore: # Your coore package
  go_router: ^14.0.0

dev_dependencies:
  build_runner: ^2.4.0
  go_router_builder: ^2.7.0
```

### 2. Create Route Definitions

Create `lib/src/config/app_router.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

// This file will be generated
part 'app_router.g.dart';

// Define your routes with annotations
@TypedGoRoute<SplashRoute>(path: '/splash')
class SplashRoute extends GoRouteData {
  @override
  Widget build(BuildContext context, GoRouterState state) {
    return const SplashScreen();
  }
}

@TypedGoRoute<LoginRoute>(path: '/login')
class LoginRoute extends GoRouteData {
  @override
  Widget build(BuildContext context, GoRouterState state) {
    return const LoginScreen();
  }
}

// Route with parameters
@TypedGoRoute<UserDetailsRoute>(path: '/users/:id')
class UserDetailsRoute extends GoRouteData {
  const UserDetailsRoute({required this.id, this.tab});

  final String id;
  final String? tab; // Query parameter

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return UserDetailsScreen(userId: id, initialTab: tab);
  }
}
```

### 3. Generate Code

Run the code generator:

```bash
dart run build_runner build
# or for watch mode:
dart run build_runner watch
```

This generates `app_router.g.dart` with:
- `$appRoutes` - List of routes for GoRouter
- Extension methods like `context.goUserDetails(id: '123')`
- Route location builders

### 4. Configure Navigation

Create your navigation config:

```dart
@lazySingleton
class AppNavigationConfig {
  AppNavigationConfig(this.authCubit) {
    navigationConfigEntity = _buildNavigationConfigEntity();
  }

  final AuthCubit authCubit;
  late final NavigationConfigEntity navigationConfigEntity;

  NavigationConfigEntity _buildNavigationConfigEntity() {
    return NavigationConfigEntity(
      // Use the generated routes
      routes: $appRoutes,
      
      // Optional: Add redirect logic
      redirect: (context, state) {
        final isAuthenticated = authCubit.state.isAuthenticated;
        final isOnLoginPage = state.matchedLocation == '/login';

        if (!isAuthenticated && !isOnLoginPage) {
          return '/login';
        }
        return null;
      },
      
      // Optional: Refresh on auth changes
      refreshListenable: authCubit.stream.toListenable(),
    );
  }
}
```

### 5. Register in DI

The `coore` package automatically registers both `CoreRouter` and `GoRouter`:

```dart
// In your app initialization
await CoreConfig.initializeCoreDependenciesAfterProjectSetup(
  CoreConfigAfterProjectSetupEntity(
    navigationConfigEntity: getIt<AppNavigationConfig>().navigationConfigEntity,
    shouldLog: true,
  ),
);

// Now you have access to:
// - getIt<CoreRouter>() - The router manager
// - getIt<GoRouter>() - The router instance (for BLoCs)
```

## Defining Routes

### Simple Route

```dart
@TypedGoRoute<HomeRoute>(path: '/home')
class HomeRoute extends GoRouteData {
  @override
  Widget build(BuildContext context, GoRouterState state) {
    return const HomeScreen();
  }
}
```

### Route with Path Parameters

```dart
@TypedGoRoute<ProductDetailsRoute>(path: '/products/:productId')
class ProductDetailsRoute extends GoRouteData {
  const ProductDetailsRoute({required this.productId});

  final String productId;

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return ProductDetailsScreen(productId: productId);
  }
}
```

### Route with Query Parameters

```dart
@TypedGoRoute<SearchRoute>(path: '/search')
class SearchRoute extends GoRouteData {
  const SearchRoute({this.query, this.category});

  final String? query;
  final String? category;

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return SearchScreen(query: query, category: category);
  }
}
```

### Nested Routes

```dart
@TypedGoRoute<UserRoute>(
  path: '/users/:userId',
  routes: [
    TypedGoRoute<UserPostsRoute>(path: 'posts'),
    TypedGoRoute<UserSettingsRoute>(path: 'settings'),
  ],
)
class UserRoute extends GoRouteData {
  const UserRoute({required this.userId});
  final String userId;

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return UserScreen(userId: userId);
  }
}

class UserPostsRoute extends GoRouteData {
  const UserPostsRoute({required this.userId});
  final String userId;

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return UserPostsScreen(userId: userId);
  }
}
```

### StatefulShellRoute (Bottom Navigation)

```dart
@TypedStatefulShellRoute<MainShellRoute>(
  branches: [
    TypedStatefulShellBranch<HomeBranch>(
      routes: [TypedGoRoute<HomeRoute>(path: '/home')],
    ),
    TypedStatefulShellBranch<ProfileBranch>(
      routes: [TypedGoRoute<ProfileRoute>(path: '/profile')],
    ),
  ],
)
class MainShellRoute extends StatefulShellRouteData {
  @override
  Widget build(
    BuildContext context,
    GoRouterState state,
    StatefulNavigationShell navigationShell,
  ) {
    return MainScreen(navigationShell: navigationShell);
  }
}

class HomeBranch extends ShellBranchData {}
class ProfileBranch extends ShellBranchData {}
```

## Navigation from Widgets

### Using Generated Extensions

```dart
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      // Type-safe navigation with autocomplete!
      onPressed: () => context.goUserDetails(id: '123', tab: 'posts'),
      child: Text('View User'),
    );
  }
}
```

### Available Methods

```dart
// Navigate (replace current route)
context.goUserDetails(id: '123');

// Push (add to stack)
context.pushUserDetails(id: '123');

// Push and wait for result
final result = await context.pushUserDetails(id: '123');

// Replace
context.replaceUserDetails(id: '123');
```

## Navigation from BLoCs/Services

### Using GoRouter Instance

```dart
class UserBloc extends Bloc<UserEvent, UserState> {
  final GoRouter router;

  UserBloc(this.router);

  void navigateToUserDetails(String userId) {
    // Build the route location
    final location = UserDetailsRoute(id: userId, tab: 'profile').location;
    
    // Navigate using the router
    router.push(location);
  }

  void goBack() {
    router.pop();
  }
}
```

### Showing Dialogs from BLoCs

```dart
class MyService {
  void showErrorDialog(String message) {
    final context = CoreRouter.rootNavigatorKey.currentContext!;
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Error'),
        content: Text(message),
      ),
    );
  }
}
```

## Advanced Patterns

### Redirect Logic

```dart
NavigationConfigEntity(
  routes: $appRoutes,
  redirect: (context, state) {
    final authState = context.read<AuthCubit>().state;
    
    // Redirect to login if not authenticated
    if (!authState.isAuthenticated) {
      if (state.matchedLocation != '/login') {
        return '/login';
      }
    }
    
    // Redirect to onboarding if not completed
    if (!authState.hasCompletedOnboarding) {
      if (state.matchedLocation != '/onboarding') {
        return '/onboarding';
      }
    }
    
    return null; // No redirect
  },
)
```

### Dynamic Route Refresh

```dart
// When auth state changes, refresh the router
class AuthCubit extends Cubit<AuthState> {
  final CoreRouter coreRouter;

  AuthCubit(this.coreRouter);

  void logout() {
    emit(AuthState.unauthenticated());
    // Refresh router to re-evaluate redirects
    coreRouter.refreshRouter();
  }
}
```

### Custom Transitions

```dart
@TypedGoRoute<FadeRoute>(path: '/fade')
class FadeRoute extends GoRouteData {
  @override
  Page<void> buildPage(BuildContext context, GoRouterState state) {
    return CustomTransitionPage(
      key: state.pageKey,
      child: const FadeScreen(),
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(opacity: animation, child: child);
      },
    );
  }
}
```

## Migration Guide

### From String-Based Navigation

**Before:**
```dart
// Hard to refactor, no type safety
Navigator.pushNamed(context, '/users/123');
context.go('/users/123?tab=posts');
```

**After:**
```dart
// Type-safe, refactorable
context.goUserDetails(id: '123', tab: 'posts');
```

### From Custom TypedRoute System

**Before:**
```dart
class UserDetailsParams extends BaseScreenParams {
  final String userId;
  // ... boilerplate ...
}

class UserDetailsRoute extends TypedRoute<UserDetailsParams> {
  // ... more boilerplate ...
}

AppRoutes.userDetails.goNamed(navigator, UserDetailsParams(userId: '123'));
```

**After:**
```dart
// Just define the route
@TypedGoRoute<UserDetailsRoute>(path: '/users/:id')
class UserDetailsRoute extends GoRouteData {
  const UserDetailsRoute({required this.id});
  final String id;

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return UserDetailsScreen(userId: id);
  }
}

// Navigate
context.goUserDetails(id: '123');
```

## Best Practices

1. **Use code generation**: Let `go_router_builder` handle the boilerplate
2. **Keep routes in one file**: Easier to maintain and understand
3. **Use const constructors**: Better performance
4. **Inject GoRouter in BLoCs**: Enables context-less navigation
5. **Use CoreRouter.rootNavigatorKey**: For dialogs/snackbars from BLoCs
6. **Run build_runner in watch mode**: Automatic regeneration during development

## Summary

The `coore` package's `CoreRouter` provides a clean foundation for navigation by:
- Managing the `GoRouter` instance
- Handling configuration and refresh logic
- Providing the root navigator key
- Integrating navigation observers

Use `go_router_builder` for type-safe route definitions and navigation methods. This combination gives you the best of both worlds: robust infrastructure from `coore` and type-safe navigation from `go_router_builder`.

