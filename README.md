# üéØ Coore

[![Flutter](https://img.shields.io/badge/Flutter-3.10+-blue.svg)](https://flutter.dev/)
[![Dart](https://img.shields.io/badge/Dart-3.10+-blue.svg)](https://dart.dev/)
[![License](https://img.shields.io/badge/License-MIT-blue.svg)](./LICENSE)

**Enterprise-grade Flutter infrastructure package** built on Clean Architecture principles with functional error handling and centralized configuration.

---

## ‚ú® Features

- üèóÔ∏è **Clean Architecture** - Strict separation of concerns with feature-first organization
- üîÑ **Functional Error Handling** - Type-safe error handling with `fpdart`'s `Either` monad
- üåê **Networking** - Dio-based API handler with automatic token refresh and request cancellation
- üìä **State Management** - Simplified BLoC/Cubit patterns with automatic API state handling
- üé® **UI Components** - Production-ready widgets for pagination, forms, images, and theming
- üß≠ **Navigation** - GoRouter integration with type-safe route generation support
- üíæ **Storage** - Local (Hive) and secure (FlutterSecureStorage) database abstractions
- ‚öôÔ∏è **Centralized Configuration** - Single entry point for app-wide setup

---

## üì¶ Installation

Add `coore` to your `pubspec.yaml`:

```yaml
dependencies:
  coore: ^1.0.0
```

Then run:

```bash
flutter pub get
```

---

## üöÄ Quick Start

### Critical Setup: Initialize Core Dependencies

**Coore requires initialization before `runApp()`**. This single call configures networking, theming, localization, and environment settings.

```dart
import 'package:coore/coore.dart';
import 'package:flutter/material.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize all core dependencies
  await CoreConfig.initializeCoreDependencies(
    CoreConfigEntity(
      currentEnvironment: CoreEnvironment.development,
      networkConfigEntity: NetworkConfigEntity(
        baseUrl: 'https://api.example.com',
        connectTimeout: const Duration(seconds: 30),
        sendTimeout: const Duration(seconds: 30),
        receiveTimeout: const Duration(seconds: 30),
        authInterceptorType: AuthInterceptorType.tokenBased,
      ),
      localizationConfigEntity: LocalizationConfigEntity(
        defaultLocale: const Locale('en'),
        supportedLocales: const [Locale('en'), Locale('ar')],
        localizationsDelegates: [
          // Your localization delegates
        ],
      ),
      themeConfigEntity: ThemeConfigEntity(
        lightTheme: ThemeData.light(),
        darkTheme: ThemeData.dark(),
      ),
    ),
  );
  
  runApp(MyApp());
}
```

**After project setup** (e.g., after initializing Hive boxes), initialize navigation:

```dart
await CoreConfig.initializeCoreDependenciesAfterProjectSetup(
  CoreConfigAfterProjectSetupEntity(
    navigationConfigEntity: NavigationConfigEntity(
      routes: $appRoutes, // Generated by go_router_builder
      redirect: (context, state) {
        // Your redirect logic
        return null;
      },
    ),
  ),
);
```

---

## üìö Module Guide

### üåê Networking

Coore provides a type-safe API handler that wraps all network calls in `Either<Failure, T>`, enabling functional error handling with granular failure types.

#### Making API Requests

```dart
import 'package:coore/coore.dart';
import 'package:get_it/get_it.dart';

final apiHandler = getIt<ApiHandlerInterface>();

// GET request with cancellation support
final result = await apiHandler.get<List<User>>(
  '/users',
  parser: (json) => (json['data'] as List)
      .map((item) => User.fromJson(item as Map<String, dynamic>))
      .toList(),
  queryParameters: {'page': 1, 'limit': 20},
  shouldCache: true,
  isAuthorized: true,
  requestId: 'fetch-users', // Optional: for cancellation
);

// Handle the Either result with type-safe error handling
result.fold(
  (failure) {
    // Handle specific failure types
    if (failure is ConnectionFailure) {
      // Show offline message
      print('No internet: ${failure.message}');
    } else if (failure is ServerFailure) {
      // Show server error with status code
      print('Server error ${failure.statusCode}: ${failure.message}');
    } else if (failure is AuthFailure) {
      // Navigate to login
      print('Authentication required');
    } else {
      print('Error: ${failure.message}');
    }
  },
  (users) {
    // Handle success
    print('Fetched ${users.length} users');
  },
);
```

#### Request Cancellation

```dart
import 'package:coore/coore.dart';

final cancelManager = getIt<CancelRequestManager>();

// Start a request with a requestId
apiHandler.get('/users', requestId: 'fetch-users', ...);

// Cancel it later
cancelManager.cancelRequest('fetch-users');
```

#### POST Request with Form Data

```dart
final formData = MultipartFormDataAdapter({
  'name': 'John Doe',
  'email': 'john@example.com',
  'avatar': File('/path/to/avatar.jpg'),
});

final result = await apiHandler.post<Map<String, dynamic>>(
  '/users',
  parser: (json) => json,
  formData: formData,
  onSendProgress: (progress) => print('Upload: ${(progress * 100).toInt()}%'),
  isAuthorized: true,
);
```

---

### ‚ö†Ô∏è Error Handling & Failures

Coore provides a comprehensive failure hierarchy for enterprise-grade error handling. All API calls return `Either<Failure, T>`, where `Failure` is a base class with specific subtypes for different error scenarios.

#### Failure Types

```dart
// Base Failure class with observability support
abstract class Failure extends Equatable implements Exception {
  final String message;              // User-friendly message
  final String? code;                 // Analytics code (e.g., 'AUTH_001')
  final StackTrace? stackTrace;      // For Crashlytics/Sentry
  final Object? originalException;   // Original exception for debugging
}
```

**Available Failure Types:**

- **`ConnectionFailure`** - Network-level issues (timeouts, DNS, SSL, no internet)
  - `code: 'TIMEOUT'` - Request timeout
  - `code: 'NO_INTERNET'` - No internet connection
  - `code: 'SSL_ERR'` - SSL certificate error

- **`ServerFailure`** - HTTP 4xx/5xx errors from backend
  - `statusCode` - HTTP status code (e.g., 404, 500)
  - `requestId` - Backend trace ID for log correlation

- **`AuthFailure`** - Authentication issues (401)
  - Triggers auto-logout or token refresh flows

- **`UnauthorizedFailure`** - Authorization issues (403)
  - User is logged in but lacks required permissions

- **`ValidationFailure`** - Data validation errors (422)
  - `errors: Map<String, String>` - Field-specific errors
  - `firstError` - Helper to get first error message
  - `getErrorFor(String fieldName)` - Get error for specific field

- **`BusinessFailure`** - Business rule violations (200 OK but business error)
  - Example: "Insufficient funds", "Duplicate transaction"

- **`FormatFailure`** - Data parsing issues (malformed JSON, type mismatch)

- **`CacheFailure`** - Local storage issues (database, secure storage, filesystem)

- **`OperationCancelledFailure`** - User cancelled operation

- **`UnknownFailure`** - Unexpected errors (unhandled exceptions)

#### Error Handling Example

```dart
final result = await apiHandler.get<User>('/users/123', ...);

result.fold(
  (failure) {
    // Pattern matching on failure types
    switch (failure.runtimeType) {
      case ConnectionFailure:
        // Show offline UI
        showSnackBar('No internet connection');
        break;
        
      case AuthFailure:
        // Navigate to login
        router.push('/login');
        break;
        
      case ValidationFailure:
        final validationFailure = failure as ValidationFailure;
        // Show field-specific errors
        if (validationFailure.errors.containsKey('email')) {
          showFieldError('email', validationFailure.getErrorFor('email'));
        }
        break;
        
      case ServerFailure:
        final serverFailure = failure as ServerFailure;
        // Log with request ID for backend correlation
        logger.error(
          'Server error ${serverFailure.statusCode}',
          error: serverFailure,
          stackTrace: serverFailure.stackTrace,
          extra: {'requestId': serverFailure.requestId},
        );
        showSnackBar(serverFailure.message);
        break;
        
      default:
        // Handle unknown errors
        showSnackBar(failure.message);
    }
  },
  (user) {
    // Success handling
    displayUser(user);
  },
);
```

#### Exception Mapping

Coore automatically maps Dio exceptions to appropriate failure types:

- `DioExceptionType.connectionTimeout` ‚Üí `ConnectionFailure(code: 'TIMEOUT')`
- `DioExceptionType.connectionError` ‚Üí `ConnectionFailure(code: 'NO_INTERNET')`
- `DioExceptionType.badResponse` (401) ‚Üí `AuthFailure`
- `DioExceptionType.badResponse` (403) ‚Üí `UnauthorizedFailure`
- `DioExceptionType.badResponse` (422) ‚Üí `ValidationFailure`
- `DioExceptionType.badResponse` (4xx/5xx) ‚Üí `ServerFailure`
- Generic `Exception` ‚Üí `UnknownFailure`

---

### üîÑ State Management

Coore simplifies API state management with `ApiStateHostMixin` and `ApiStateHandler`, eliminating boilerplate in your Cubits.

#### ApiState

`ApiState<T>` is a sealed class with four variants:

```dart
@freezed
sealed class ApiState<T> with _$ApiState<T> {
  const factory ApiState.initial() = Initial;
  const factory ApiState.loading() = Loading;
  const factory ApiState.succeeded(T successValue) = Succeeded;
  const factory ApiState.failed(Failure failure, {VoidCallback? retryFunction}) = Failed;
}
```

#### Using ApiStateHostMixin

```dart
import 'package:coore/coore.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_state.freezed.dart';

@freezed
class UserState with _$UserState {
  const factory UserState({
    @Default(ApiState.initial()) ApiState<List<User>> usersState,
    @Default(ApiState.initial()) ApiState<User?> currentUserState,
  }) = _UserState;
}

class UserCubit extends Cubit<UserState> with ApiStateHostMixin<UserState> {
  final UserRepository _repository;
  
  // Create handlers for each API state
  late final _usersHandler = createApiHandler<List<User>>(
    getApiState: (state) => state.usersState,
    setApiState: (state, apiState) => state.copyWith(usersState: apiState),
  );
  
  late final _currentUserHandler = createApiHandler<User?>(
    getApiState: (state) => state.currentUserState,
    setApiState: (state, apiState) => state.copyWith(currentUserState: apiState),
  );
  
  UserCubit(this._repository) : super(const UserState());
  
  Future<void> loadUsers() async {
    await _usersHandler.handleApiCall(
      apiCall: _repository.getUsers,
      params: PagePaginationParams(page: 1, limit: 20),
      onSuccess: (users) {
        print('Loaded ${users.length} users');
      },
      onFailure: (failure) {
        print('Failed: ${failure.message}');
      },
    );
  }
  
  Future<void> loadCurrentUser(String userId) async {
    await _currentUserHandler.handleApiCall(
      apiCall: (params) => _repository.getUserById(userId),
      params: NoParams(),
    );
  }
}
```

**Benefits:**
- ‚úÖ Automatic loading/success/failure state management
- ‚úÖ Built-in request cancellation
- ‚úÖ Retry functionality
- ‚úÖ Automatic cleanup on Cubit disposal

---

### üé® UI Components

#### Pagination Widget

`CorePaginationWidget` provides a complete pagination solution powered by **EasyRefresh v3** with pull-to-refresh, load-more, skeleton loading, and error handling. **Highly optimized for performance** with minimal rebuilds and efficient memory usage.

**Key Features:**
- üîÑ Pull-to-refresh with customizable headers (`MaterialHeader`, `ClassicHeader`, or custom)
- ‚¨áÔ∏è Load-more with customizable footers (`MaterialFooter`, `ClassicFooter`, or custom)
- üíÄ Skeleton loading with `Skeletonizer` integration
- ‚ö†Ô∏è Error handling with retry functionality
- üéØ Scroll-to-top FAB (optional)
- üìä Supports both `ScrollView` and `Sliver` modes

**Basic Usage:**

```dart
CorePaginationWidget<User, PageMeta>(
  paginationFunction: (batch, limit, {requestId}) async {
    return await userRepository.getUsers(
      PagePaginationParams(page: batch, limit: limit),
    );
  },
  paginationStrategy: PagePaginationStrategy(limit: 20),
  scrollableBuilder: (context, response, controller) {
    return ListView.builder(
      controller: controller,
      itemCount: response.data.length,
      itemBuilder: (context, index) {
        final user = response.data[index];
        return ListTile(
          title: Text(user.name),
          subtitle: Text(user.email),
        );
      },
    );
  },
  // Required if loadingBuilder is not provided (for skeleton loading)
  emptyEntity: const User(id: '', name: '', email: ''),
  emptyBuilder: (context) => const Center(
    child: Text('No users found'),
  ),
)
```

**Advanced Usage with Custom Headers/Footers:**

```dart
CorePaginationWidget<Product, PageMeta>(
  paginationFunction: (batch, limit, {requestId}) async {
    return await productRepository.getProducts(
      PagePaginationParams(page: batch, limit: limit),
    );
  },
  paginationStrategy: PagePaginationStrategy(limit: 20),
  scrollableBuilder: (context, response, controller) {
    return GridView.builder(
      controller: controller,
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
      ),
      itemCount: response.data.length,
      itemBuilder: (context, index) => ProductCard(
        product: response.data[index],
      ),
    );
  },
  emptyEntity: const Product(id: '', name: '', price: 0),
  // Custom refresh header
  headerBuilder: (context) => ClassicHeader(
    dragText: 'Pull to refresh',
    armedText: 'Release to refresh',
    readyText: 'Refreshing...',
    processingText: 'Refreshing...',
    processedText: 'Refreshed',
    noMoreText: 'No more',
  ),
  // Custom load-more footer
  footerBuilder: (context) => ClassicFooter(
    dragText: 'Pull to load',
    armedText: 'Release to load',
    readyText: 'Loading...',
    processingText: 'Loading...',
    processedText: 'Loaded',
    noMoreText: 'No more data',
  ),
  // Custom error builder
  errorBuilder: (context, failure, retry, alreadyFetchedItemsWidget) {
    return Column(
      children: [
        if (alreadyFetchedItemsWidget != null) 
          Expanded(child: alreadyFetchedItemsWidget),
        Center(
          child: Column(
            children: [
              Text('Error: ${failure.message}'),
              ElevatedButton(
                onPressed: retry,
                child: const Text('Retry'),
              ),
            ],
          ),
        ),
      ],
    );
  },
)
```

**Using with Existing Cubit:**

```dart
// Create cubit elsewhere
final paginationCubit = CorePaginationCubit<Product, PageMeta>(
  paginationFunction: (batch, limit, {requestId}) async {
    return await productRepository.getProducts(
      PagePaginationParams(page: batch, limit: limit),
    );
  },
  paginationStrategy: PagePaginationStrategy(limit: 20),
);

// Use in widget
CorePaginationWidget<Product, PageMeta>(
  paginationCubit: paginationCubit,
  scrollableBuilder: (context, response, controller) {
    // Your list implementation
  },
  emptyEntity: const Product(id: '', name: '', price: 0),
)
```

**Performance Optimizations:**
- ‚úÖ **BlocSelector optimization** - Only rebuilds `EasyRefresh` when `hasReachedMax` changes
- ‚úÖ **Cached skeleton placeholders** - Instance-level caching prevents regeneration on theme changes
- ‚úÖ **Lazy error widget evaluation** - `alreadyFetchedItemsWidget` only built when error builder uses it
- ‚úÖ **Efficient list concatenation** - Uses `List.from()..addAll()` for better performance with large datasets
- ‚úÖ **Widget extraction** - `_PaginationBody` isolates state listening to prevent unnecessary rebuilds

#### Form Fields

```dart
// Text field with validation
CoreTextField(
  label: 'Email',
  validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
  keyboardType: TextInputType.emailAddress,
)

// PIN/OTP field
CorePinCodeField(
  length: 6,
  onCompleted: (pin) => print('PIN: $pin'),
)
```

#### Image Widget

```dart
CoreImage.network(
  'https://example.com/image.jpg',
  width: 200,
  height: 200,
  placeholder: (context, url) => const CircularProgressIndicator(),
  errorWidget: (context, url, error) => const Icon(Icons.error),
)
```

---

### üß≠ Navigation

Coore integrates with `go_router` and is designed to work seamlessly with `go_router_builder` for type-safe navigation.

```dart
// After initialization, access the router
final router = getIt<GoRouter>();

// Navigate from BLoCs/Services
router.push('/users/123');

// Show dialogs from BLoCs
final context = CoreRouter.rootNavigatorKey.currentContext!;
showDialog(context: context, builder: (context) => AlertDialog(...));
```

For type-safe navigation with `go_router_builder`, see the [Navigation Guide](docs/NAVIGATION_GUIDE.md).

---

### üíæ Storage

#### Local Database (Hive)

```dart
// Get an instance with a named box name parameter
final localDb = getIt<NoSqlDatabaseInterface>(param1: 'userData');

// Initialize the Hive box
final initResult = await localDb.initialize();
initResult.fold(
  (failure) => print('Initialization failed: ${failure.message}'),
  (_) => print('Database initialized'),
);

// Save data
final saveResult = await localDb.save<String>('username', 'john_doe');
saveResult.fold(
  (failure) => print('Save failed: ${failure.message}'),
  (_) => print('Data saved'),
);

// Read data
final username = await localDb.get<String>('username');
username.fold(
  (failure) => print('Error: ${failure.message}'),
  (value) => print('Username: $value'),
);

// Close when done
await localDb.close();
```

#### Secure Storage

```dart
final secureDb = getIt<SecureDatabaseInterface>();

// Initialize
await secureDb.initialize();

// Write sensitive data
await secureDb.write('token', 'secret_token');

// Read
final token = await secureDb.read('token');
```

---

## üèóÔ∏è Architecture

Coore enforces **Clean Architecture** with a **feature-first** organization:

```
lib/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ api_handler/          # Networking layer
‚îÇ   ‚îú‚îÄ‚îÄ state_management/      # BLoC state management
‚îÇ   ‚îú‚îÄ‚îÄ ui/                    # UI components
‚îÇ   ‚îú‚îÄ‚îÄ config/                # Configuration & DI
‚îÇ   ‚îú‚îÄ‚îÄ error_handling/        # Error handling & failures
‚îÇ   ‚îú‚îÄ‚îÄ local_storage/         # Data persistence
‚îÇ   ‚îî‚îÄ‚îÄ navigation/            # Routing
```

### Key Principles

1. **Separation of Concerns** - Each module has a single responsibility
2. **Dependency Injection** - GetIt-based service locator pattern
3. **Functional Error Handling** - `Either<Failure, T>` for type-safe error handling
4. **Immutable State** - Freezed-based state classes
5. **Type Safety** - Strong typing throughout the API

---

## üîß Available Services

After initialization, the following services are available via `getIt`:

- `ApiHandlerInterface` - HTTP client
- `CancelRequestManager` - Request cancellation
- `NetworkStatusInterface` - Network connectivity monitoring
- `NoSqlDatabaseInterface` - Local storage (Hive) - Requires `param1: 'boxName'`
- `SecureDatabaseInterface` - Secure storage
- `ThemeCubit` - Theme management
- `LocalizationCubit` - Localization management
- `PlatformCubit` - Platform information
- `CoreLogger` - Logging service
- `CoreRouter` - Router manager
- `GoRouter` - Router instance

---

## üìñ Additional Resources

- [Navigation Guide](docs/NAVIGATION_GUIDE.md) - Comprehensive navigation documentation


---

## ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

---


**Built with ‚ù§Ô∏è for the Flutter community**

